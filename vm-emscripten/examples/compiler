use strict;
use warnings;
use constant EXIT => 0x00;
use constant INT_STORE    => 0x01;
use constant INT_PRINT    => 0x02;
use constant INT_TOSTRING => 0x03;
use constant INT_RANDOM   => 0x04;
use constant JUMP_TO => 0x10;
use constant JUMP_Z  => 0x11;
use constant JUMP_NZ => 0x12;
use constant XOR_OP => 0x20;
use constant ADD_OP => 0x21;
use constant SUB_OP => 0x22;
use constant MUL_OP => 0x23;
use constant DIV_OP => 0x24;
use constant INC_OP => 0x25;
use constant DEC_OP => 0x26;
use constant AND_OP => 0x27;
use constant OR_OP  => 0x28;
use constant STRING_STORE  => 0x30;
use constant STRING_PRINT  => 0x31;
use constant STRING_CONCAT => 0x32;
use constant STRING_SYSTEM => 0x33;
use constant STRING_TOINT  => 0x34;
use constant CMP_REG       => 0x40;
use constant CMP_IMMEDIATE => 0x41;
use constant CMP_STRING    => 0x42;
use constant IS_STRING     => 0x43;
use constant IS_INTEGER    => 0x44;
use constant NOP_OP    => 0x50;
use constant REG_STORE => 0x51;
use constant PEEK   => 0x60;
use constant POKE   => 0x61;
use constant MEMCPY => 0x62;
use constant STACK_PUSH => 0x70;
use constant STACK_POP  => 0x71;
use constant STACK_RET  => 0x72;
use constant STACK_CALL => 0x73;
while ( my $file = shift )
{
    my %LABELS;
    my @UPDATES;
    my $output = $file;
    $output =~ s/\.[^.]+$//;
    $output .= ".raw";
    open( my $in,  "<", $file )   or die "Failed to read source $file - $!";
    open( my $out, ">", $output ) or die "Failed to write to $output - $!";
    my $offset = 0;
    while ( my $line = <$in> )
    {
        chomp($line);
        next if ( !length($line) || ( $line =~ /^\s*
        if ( $line =~ /^\s*:(.*)/ )
        {
            my $name = $1;
            if ( $LABELS{ $name } )
            {
                print "WARNING: Label name '$name' defined multiple times!\n";
                print "         Picking first occurrence.\n";
                print "         This is probably your bug.\n";
            }
            if ( ( $name =~ /^0x/i ) || ( $name =~ /^([0-9]+)$/ ) )
            {
                print
                  "WARNING: Label named '$name' WILL be confused for an address\n";
                print "         Strongly consider changing this\n";
            }
            $LABELS{ $name } = $offset;
        }
        elsif ( $line =~ /^\s+store\s+
        {
            my $reg = $1;
            my $str = $2;
            $str =~ s/(\\n|\\t)/"qq{$1}"/gee;
            my $len = length($str);
            my $len1 = $len % 256;
            my $len2 = ( $len - $len1 ) / 256;
            print $out chr STRING_STORE;
            print $out chr $reg;
            print $out chr $len1;
            print $out chr $len2;
            print $out $str;
            $offset += 4;              
            $offset += length($str);
        }
        elsif ( $line =~ /^\s+store\s+
        {
            my $dest = $1;
            my $src  = $2;
            print $out chr REG_STORE;
            print $out chr $dest;
            print $out chr $src;
            $offset += 3;    
        }
        elsif ( $line =~ /^\s+store\s+
        {
            my $reg = $1;
            my $val = $2;
            if ( ( $val =~ /^0x/ ) ||
                 ( $val =~ /^([0-9]+)$/ ) )
            {
                $val = hex($val) if ( $val =~ /^0x/i );
                die "Int too large" if ( $val > 65535 );
                my $val1 = $val % 256;
                my $val2 = ( $val - $val1 ) / 256;
                print $out chr INT_STORE;
                print $out chr $reg;
                print $out chr $val1;
                print $out chr $val2;
                $offset += 4;    
            }
            else
            {
                print $out chr INT_STORE;
                print $out chr $reg;
                print $out chr 0x00;
                print $out chr 0x00;
                $offset += 4;    
                push( @UPDATES,
                      {  offset => ( $offset - 2 ),
                         label  => $val
                      } );
            }
        }
        elsif ( $line =~ /^\s+exit/ )
        {
            print $out chr EXIT;
            $offset += 1;
        }
        elsif ( $line =~ /^\s+nop/ )
        {
            print $out chr NOP_OP;
            $offset += 1;
        }
        elsif ( $line =~ /^\s*print_int\s?
        {
            my $reg = $1;
            print $out chr INT_PRINT;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*print_str\s?
        {
            my $reg = $1;
            print $out chr STRING_PRINT;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*system\s?
        {
            my $reg = $1;
            print $out chr STRING_SYSTEM;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*(goto|jmp|jmpz|jmpnz|call)\s+([^\s]+)\s*/ )
        {
            my $type = $1;
            my $dest = $2;
            my %types = ( goto  => JUMP_TO,
                          jmp   => JUMP_TO,
                          jmpz  => JUMP_Z,
                          jmpnz => JUMP_NZ,
                          call  => STACK_CALL
                        );
            if ( ( $dest =~ /^0x/ ) ||
                 ( $dest =~ /^([0-9]+)$/ ) )
            {
                $dest = hex($dest) if ( $dest =~ /0x/i );
                my $a1 = $dest % 256;
                my $a2 = ( $dest - $a1 ) / 256;
                print $out chr $types{ $type };
                print $out chr $a1;
                print $out chr $a2;
                $offset += 3;    
            }
            else
            {
                print $out chr $types{ $type };
                print $out chr 0;    
                print $out chr 0;    
                $offset += 3;        
                push( @UPDATES,
                      {  offset => ( $offset - 2 ),
                         label  => $dest
                      } );
            }
        }
        elsif ( $line =~
            /^\s*(add|and|sub|mul|div|or|xor|concat)\s+
          )
        {
            my %maths = ( add    => ADD_OP,
                          and    => AND_OP,
                          or     => OR_OP,
                          sub    => SUB_OP,
                          mul    => MUL_OP,
                          div    => DIV_OP,
                          xor    => XOR_OP,
                          concat => STRING_CONCAT,
                        );
            my $opr  = $1;
            my $dest = $2;
            my $src1 = $3;
            my $src2 = $4;
            print $out chr $maths{ lc $opr };
            print $out chr $dest;
            print $out chr $src1;
            print $out chr $src2;
            $offset += 4;    
        }
        elsif ( $line =~ /^\s*dec\s+
        {
            my $reg = $1;
            print $out chr DEC_OP;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*inc\s+
        {
            my $reg = $1;
            print $out chr INC_OP;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*int2string\s+
        {
            my $reg = $1;
            print $out chr INT_TOSTRING;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*random\s+
        {
            my $reg = $1;
            print $out chr INT_RANDOM;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*string2int\s+
        {
            my $reg = $1;
            print $out chr STRING_TOINT;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*cmp\s+
        {
            my $reg1 = $1;
            my $reg2 = $2;
            print $out chr CMP_REG;
            print $out chr $reg1;
            print $out chr $reg2;
            $offset += 3;
        }
        elsif ( $line =~ /^\s+cmp\s+
        {
            my $reg = $1;
            my $str = $2;
            my $len = length($str);
            my $len1 = $len % 256;
            my $len2 = ( $len - $len1 ) / 256;
            print $out chr CMP_STRING;
            print $out chr $reg;
            print $out chr $len1;
            print $out chr $len2;
            print $out $str;
            $offset += 4;              
            $offset += length($str);
        }
        elsif ( $line =~ /^\s*cmp\s+
        {
            my $reg = $1;
            my $val = $2;
            $val = hex($val) if ( $val =~ /^0x/i );
            my $val1 = $val % 256;
            my $val2 = ( $val - $val1 ) / 256;
            print $out chr CMP_IMMEDIATE;
            print $out chr $reg;
            print $out chr $val1;
            print $out chr $val2;
            $offset += 4;    
        }
        elsif ( $line =~ /^\s*is_(string|integer)\s+
        {
            my $type = $1;
            my $reg  = $2;
            if ( $type =~ /string/i )
            {
                print $out chr IS_STRING;
            }
            if ( $type =~ /integer/i )
            {
                print $out chr IS_INTEGER;
            }
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*peek\s+
        {
            my $reg  = $1;
            my $addr = $2;
            print $out chr PEEK;
            print $out chr $reg;
            print $out chr $addr;
            $offset += 3;
        }
        elsif ( $line =~ /^\s*poke\s+
        {
            my $reg  = $1;
            my $addr = $2;
            print $out chr POKE;
            print $out chr $reg;
            print $out chr $addr;
            $offset += 3;
        }
        elsif (
             $line =~ /^\s*memcpy\s+
        {
            my $src = $1;
            my $dst = $2;
            my $len = $3;
            print $out chr MEMCPY;
            print $out chr $src;
            print $out chr $dst;
            print $out chr $len;
            $offset += 4;
        }
        elsif ( $line =~ /^\s*(push|pop)\s+
        {
            my $opr = $1;
            my $reg = $2;
            print $out chr STACK_PUSH if ( $opr =~ /push/i );
            print $out chr STACK_POP  if ( $opr =~ /pop/i );
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*ret\s*/ )
        {
            print $out chr STACK_RET;
            $offset += 1;
        }
        elsif ( $line =~ /^\s*(db|data)\s+(.*)/i )
        {
            my $data = $2;
            foreach my $db ( split( /,/, $data ) )
            {
                $db =~ s/^\s+|\s+$//g;
                next unless ( length($db) );
                $db = hex($db) if ( $db =~ /^0x/i );
                die "Data too large for a byte: $db" if ( $db > 255 );
                print $out chr $db;
                $offset += 1;
            }
        }
        else
        {
            print "WARNING UNKNOWN LINE: $line\n";
        }
    }
    if ( $offset < 1 )
    {
        print "WARNING: Didn't generate any code\n";
    }
    close($in);
    close($out);
    if ( scalar @UPDATES )
    {
        open( my $tmp, "+<", $output ) or die "Failed to write to output - $!";
        foreach my $update (@UPDATES)
        {
            my $offset = $update->{ 'offset' };
            my $label  = $update->{ 'label' };
            seek $tmp, $offset, 0;
            my $target = $LABELS{ $label };
            die "No target for label '$label' - Label not defined!"
              unless ( defined($target) );
            my $t1 = $target % 256;
            my $t2 = ( $target - $t1 ) / 256;
            print $tmp chr $t1;
            print $tmp chr $t2;
        }
        close($tmp);
    }
}